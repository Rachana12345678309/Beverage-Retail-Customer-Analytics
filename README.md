# Retail Analytics: Customer Behavior & Product Performance

This project implements a comprehensive relational database analysis for a retail business. By joining fact tables with dimension tables (Location and Product), the script extracts critical business intelligence regarding sales, marketing efficiency, and geographical profitability.

## Overview

The analysis is structured around a **Star Schema** concept, where the `Fact` table contains quantitative data (Sales, Profit, COGS) and is linked to `Location` and `Product` dimension tables via keys.



## Key Business Insights & SQL Implementation

### 1. Aggregation & Financial Metrics
The script answers vital business questions using aggregate functions:
- **Total Marketing Spend:** Calculated by summing marketing investments for specific product IDs.
- **Profitability Analysis:** Using `SUM()` and `AVG()` to determine the financial health of specific regions, such as the total profit generated by the state of Colorado.
- **Sales Extremes:** Identifying minimum and maximum values for Sales and COGS (Cost of Goods Sold).

### 2. Multi-Table Joins
To bridge the gap between "where" things happen and "what" is being sold, the project utilizes:
- **Inner Joins:** To combine sales data with product details.
- **Full Outer Joins:** Used specifically to link `Fact` and `Location` tables by `Area_Code` to calculate state-level performance.



### 3. Advanced Filtering & Logic
- **Regex & Pattern Matching:** Using `LIKE` to find specific product name patterns.
- **Set Theory:** Implementing `UNION` and `INTERSECT` to compare area codes across different tables, identifying unique versus shared geographical regions.
- **Case Logic:** Categorizing sales performance based on high/low total expenses.

### 4. Database Programmability
- **Table-Valued Functions:** Created a function `userchoice` that allows dynamic filtering. It returns a subset of the Product table based on a user-provided `Product_Type` (e.g., 'Espresso').
- **Transaction Control:** Using `BEGIN TRANSACTION` and `ROLLBACK` to safely test data modifications, such as changing product types or deleting "Regular" type records.

### 5. String & Metadata Analysis
Exploration of SQL's built-in string functions:
- `LOWER()` and `UPPER()` for data normalization.
- `ASCII()` and `SUBSTRING()` to analyze specific characters within product strings.
- `LEN()` to calculate the length of product names for UI/UX considerations.

## Tech Stack
- **Language:** T-SQL (MS SQL Server)
- **Functions:** SUM, AVG, COUNT, MIN/MAX, ASCII, SUBSTRING, UNION/INTERSECT.
- **Advanced:** Table-Valued Functions, Transaction Management, Multi-table Joins.

## How to Run

1. **Database Creation:**
   ```sql
   USE assignments;

2. **Schema Setup:**
   Ensure your environment has the fact, location, and product tables populated.

3. **Function Deployment:**
   Run the CREATE FUNCTION block for userchoice.

4. **Analysis:**
   Execute queries 1 through 29 to generate the full suite of retail reports.
